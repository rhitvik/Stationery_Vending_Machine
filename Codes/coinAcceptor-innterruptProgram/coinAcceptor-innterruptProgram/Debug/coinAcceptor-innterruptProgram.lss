
coinAcceptor-innterruptProgram.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000800  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000d4  00800060  00000800  00000894  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001f  00800134  00800134  00000968  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000968  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00001034  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000080  00000000  00000000  000010c0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000132e  00000000  00000000  00001140  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000234  00000000  00000000  0000246e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000062a  00000000  00000000  000026a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000248  00000000  00000000  00002ccc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000631  00000000  00000000  00002f14  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000059f  00000000  00000000  00003545  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 06 01 	jmp	0x20c	; 0x20c <__vector_9>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 e0       	ldi	r30, 0x00	; 0
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 33       	cpi	r26, 0x34	; 52
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	a4 e3       	ldi	r26, 0x34	; 52
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a3 35       	cpi	r26, 0x53	; 83
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 01 03 	call	0x602	; 0x602 <main>
  8a:	0c 94 fe 03 	jmp	0x7fc	; 0x7fc <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <_Z14disable_driverv>:
	}			
}	

void disable_driver(void)
{
	PORTD &=~ (1<<PIND6);
  92:	96 98       	cbi	0x12, 6	; 18
	PORTD &=~ (1<<PIND7);
  94:	97 98       	cbi	0x12, 7	; 18
	PORTD &=~ (1<<PIND5);
  96:	95 98       	cbi	0x12, 5	; 18
}
  98:	08 95       	ret

0000009a <_Z11accept_coinv>:

void accept_coin(void)
{
	//clockwise
	PORTD |= (1<<PIND6);
  9a:	96 9a       	sbi	0x12, 6	; 18
	PORTD &=~ (1<<PIND7);
  9c:	97 98       	cbi	0x12, 7	; 18
}
  9e:	08 95       	ret

000000a0 <_Z11return_coinv>:
void return_coin(void)
{
	//anticlockwise
	PORTD |= (1<<PIND7);
  a0:	97 9a       	sbi	0x12, 7	; 18
	PORTD &=~ (1<<PIND6);
  a2:	96 98       	cbi	0x12, 6	; 18
}
  a4:	08 95       	ret

000000a6 <_Z14initialise_PWMv>:
	disable_driver();
}

void initialise_PWM(void)
{
	TCCR1A |= (1<<WGM11);
  a6:	8f b5       	in	r24, 0x2f	; 47
  a8:	82 60       	ori	r24, 0x02	; 2
  aa:	8f bd       	out	0x2f, r24	; 47
	TCCR1B |= (1<<WGM12) |(1<<WGM13) |(1<<CS10);
  ac:	8e b5       	in	r24, 0x2e	; 46
  ae:	89 61       	ori	r24, 0x19	; 25
  b0:	8e bd       	out	0x2e, r24	; 46
	ICR1=19999; //top value
  b2:	8f e1       	ldi	r24, 0x1F	; 31
  b4:	9e e4       	ldi	r25, 0x4E	; 78
  b6:	97 bd       	out	0x27, r25	; 39
  b8:	86 bd       	out	0x26, r24	; 38
}
  ba:	08 95       	ret

000000bc <_Z19initialise_PWM_coinv>:
void initialise_PWM_coin(void)
{
	TCCR1A |= (1<<COM1A1);
  bc:	8f b5       	in	r24, 0x2f	; 47
  be:	80 68       	ori	r24, 0x80	; 128
  c0:	8f bd       	out	0x2f, r24	; 47
	OCR1A = 5000; ///////put the ocr value
  c2:	88 e8       	ldi	r24, 0x88	; 136
  c4:	93 e1       	ldi	r25, 0x13	; 19
  c6:	9b bd       	out	0x2b, r25	; 43
  c8:	8a bd       	out	0x2a, r24	; 42
}
  ca:	08 95       	ret

000000cc <_Z23initialise_PWM_dispatchv>:
void initialise_PWM_dispatch(void)
{
	TCCR1A |= (1<<COM1B1);
  cc:	8f b5       	in	r24, 0x2f	; 47
  ce:	80 62       	ori	r24, 0x20	; 32
  d0:	8f bd       	out	0x2f, r24	; 47
	OCR1B = 3500; ///////put the ocr value 
  d2:	8c ea       	ldi	r24, 0xAC	; 172
  d4:	9d e0       	ldi	r25, 0x0D	; 13
  d6:	99 bd       	out	0x29, r25	; 41
  d8:	88 bd       	out	0x28, r24	; 40
}
  da:	08 95       	ret

000000dc <_Z19sw_debounce_pressedv>:
	pressed_confidence_level++;
	if(pressed_confidence_level>=500 )//put a debouncing value///////////////
	{
		pressed_confidence_level=0;
	}
}
  dc:	08 95       	ret

000000de <_Z20sw_debounce_releasedv>:

	if(released_confidence_level>=500 )//put a debouncing value//////////////
	{
		released_confidence_level=0;
	}
}
  de:	08 95       	ret

000000e0 <_Z13stop_PWM_coinv>:

void stop_PWM_coin(void)
{
	TCCR1A &=~ (1<<COM1A1);
  e0:	8f b5       	in	r24, 0x2f	; 47
  e2:	8f 77       	andi	r24, 0x7F	; 127
  e4:	8f bd       	out	0x2f, r24	; 47
	OCR1A = 0;
  e6:	1b bc       	out	0x2b, r1	; 43
  e8:	1a bc       	out	0x2a, r1	; 42
}
  ea:	08 95       	ret

000000ec <_Z17stop_PWM_dispatchv>:
void stop_PWM_dispatch(void)
{
	TCCR1A &=~ (1<<COM1B1);
  ec:	8f b5       	in	r24, 0x2f	; 47
  ee:	8f 7d       	andi	r24, 0xDF	; 223
  f0:	8f bd       	out	0x2f, r24	; 47
	OCR1B = 0;
  f2:	19 bc       	out	0x29, r1	; 41
  f4:	18 bc       	out	0x28, r1	; 40
}
  f6:	08 95       	ret

000000f8 <_Z18dispatch_parameterv>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  f8:	83 ed       	ldi	r24, 0xD3	; 211
  fa:	90 e3       	ldi	r25, 0x30	; 48
  fc:	01 97       	sbiw	r24, 0x01	; 1
  fe:	f1 f7       	brne	.-4      	; 0xfc <_Z18dispatch_parameterv+0x4>
 100:	00 c0       	rjmp	.+0      	; 0x102 <_Z18dispatch_parameterv+0xa>
 102:	00 00       	nop

void dispatch_parameter(void)
{
	_delay_ms(50);
	PORTD |= (1<<PIND2);
 104:	92 9a       	sbi	0x12, 2	; 18
	PORTD &=~ (1<<PIND3);
 106:	93 98       	cbi	0x12, 3	; 18
 108:	83 ed       	ldi	r24, 0xD3	; 211
 10a:	90 e3       	ldi	r25, 0x30	; 48
 10c:	01 97       	sbiw	r24, 0x01	; 1
 10e:	f1 f7       	brne	.-4      	; 0x10c <_Z18dispatch_parameterv+0x14>
 110:	00 c0       	rjmp	.+0      	; 0x112 <_Z18dispatch_parameterv+0x1a>
 112:	00 00       	nop
	_delay_ms(50);
}
 114:	08 95       	ret

00000116 <_Z25unable_dispatch_parameterv>:
 116:	83 ed       	ldi	r24, 0xD3	; 211
 118:	90 e3       	ldi	r25, 0x30	; 48
 11a:	01 97       	sbiw	r24, 0x01	; 1
 11c:	f1 f7       	brne	.-4      	; 0x11a <_Z25unable_dispatch_parameterv+0x4>
 11e:	00 c0       	rjmp	.+0      	; 0x120 <_Z25unable_dispatch_parameterv+0xa>
 120:	00 00       	nop
void unable_dispatch_parameter(void)
{
	_delay_ms(50);
	PORTD &=~ (1<<PIND2);
 122:	92 98       	cbi	0x12, 2	; 18
	PORTD &=~ (1<<PIND3);
 124:	93 98       	cbi	0x12, 3	; 18
	PORTD &=~ (1<<PIND4);
 126:	94 98       	cbi	0x12, 4	; 18
 128:	83 ed       	ldi	r24, 0xD3	; 211
 12a:	90 e3       	ldi	r25, 0x30	; 48
 12c:	01 97       	sbiw	r24, 0x01	; 1
 12e:	f1 f7       	brne	.-4      	; 0x12c <_Z25unable_dispatch_parameterv+0x16>
 130:	00 c0       	rjmp	.+0      	; 0x132 <_Z25unable_dispatch_parameterv+0x1c>
 132:	00 00       	nop
	_delay_ms(50);
}
 134:	08 95       	ret

00000136 <_Z18initialise_counterv>:

void initialise_counter(void)
{
	TCCR0 |= (1<<CS01)|(1<<CS00);
 136:	83 b7       	in	r24, 0x33	; 51
 138:	83 60       	ori	r24, 0x03	; 3
 13a:	83 bf       	out	0x33, r24	; 51
	TIMSK |= (1<<TOIE0);
 13c:	89 b7       	in	r24, 0x39	; 57
 13e:	81 60       	ori	r24, 0x01	; 1
 140:	89 bf       	out	0x39, r24	; 57
	TCNT0 = 0;
 142:	12 be       	out	0x32, r1	; 50
}
 144:	08 95       	ret

00000146 <_Z12stop_counterv>:
void stop_counter(void)
{
	TCCR0 &=~ (1<<CS00);
 146:	83 b7       	in	r24, 0x33	; 51
 148:	8e 7f       	andi	r24, 0xFE	; 254
 14a:	83 bf       	out	0x33, r24	; 51
	TCCR0 &=~ (1<<CS01);
 14c:	83 b7       	in	r24, 0x33	; 51
 14e:	8d 7f       	andi	r24, 0xFD	; 253
 150:	83 bf       	out	0x33, r24	; 51
	TIMSK &=~ (1<<TOIE0);
 152:	89 b7       	in	r24, 0x39	; 57
 154:	8e 7f       	andi	r24, 0xFE	; 254
 156:	89 bf       	out	0x39, r24	; 57
 158:	89 ef       	ldi	r24, 0xF9	; 249
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	01 97       	sbiw	r24, 0x01	; 1
 15e:	f1 f7       	brne	.-4      	; 0x15c <_Z12stop_counterv+0x16>
 160:	00 c0       	rjmp	.+0      	; 0x162 <_Z12stop_counterv+0x1c>
 162:	00 00       	nop
	_delay_ms(1);
	TCNT0=0;
 164:	12 be       	out	0x32, r1	; 50
}
 166:	08 95       	ret

00000168 <_Z23initiate_accept_processv>:
	_delay_ms(50);
	disable_driver();
}
void initiate_accept_process(void)
{
	stop_counter();
 168:	0e 94 a3 00 	call	0x146	; 0x146 <_Z12stop_counterv>
 16c:	8f e9       	ldi	r24, 0x9F	; 159
 16e:	96 e8       	ldi	r25, 0x86	; 134
 170:	a1 e0       	ldi	r26, 0x01	; 1
 172:	81 50       	subi	r24, 0x01	; 1
 174:	90 40       	sbci	r25, 0x00	; 0
 176:	a0 40       	sbci	r26, 0x00	; 0
 178:	e1 f7       	brne	.-8      	; 0x172 <_Z23initiate_accept_processv+0xa>
 17a:	00 c0       	rjmp	.+0      	; 0x17c <_Z23initiate_accept_processv+0x14>
 17c:	00 00       	nop
	_delay_ms(500);
	
	accept_coin();
 17e:	0e 94 4d 00 	call	0x9a	; 0x9a <_Z11accept_coinv>
 182:	a3 ed       	ldi	r26, 0xD3	; 211
 184:	b0 e3       	ldi	r27, 0x30	; 48
 186:	11 97       	sbiw	r26, 0x01	; 1
 188:	f1 f7       	brne	.-4      	; 0x186 <_Z23initiate_accept_processv+0x1e>
 18a:	00 c0       	rjmp	.+0      	; 0x18c <_Z23initiate_accept_processv+0x24>
 18c:	00 00       	nop
	_delay_ms(50);
	initialise_PWM_coin();
 18e:	0e 94 5e 00 	call	0xbc	; 0xbc <_Z19initialise_PWM_coinv>
 192:	8f e3       	ldi	r24, 0x3F	; 63
 194:	9d e0       	ldi	r25, 0x0D	; 13
 196:	a3 e0       	ldi	r26, 0x03	; 3
 198:	81 50       	subi	r24, 0x01	; 1
 19a:	90 40       	sbci	r25, 0x00	; 0
 19c:	a0 40       	sbci	r26, 0x00	; 0
 19e:	e1 f7       	brne	.-8      	; 0x198 <_Z23initiate_accept_processv+0x30>
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <_Z23initiate_accept_processv+0x3a>
 1a2:	00 00       	nop
	_delay_ms(1000);////calibrate it further
	stop_PWM_coin();
 1a4:	0e 94 70 00 	call	0xe0	; 0xe0 <_Z13stop_PWM_coinv>
 1a8:	a3 ed       	ldi	r26, 0xD3	; 211
 1aa:	b0 e3       	ldi	r27, 0x30	; 48
 1ac:	11 97       	sbiw	r26, 0x01	; 1
 1ae:	f1 f7       	brne	.-4      	; 0x1ac <_Z23initiate_accept_processv+0x44>
 1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <_Z23initiate_accept_processv+0x4a>
 1b2:	00 00       	nop
	_delay_ms(50);
	disable_driver();
 1b4:	0e 94 49 00 	call	0x92	; 0x92 <_Z14disable_driverv>
}
 1b8:	08 95       	ret

000001ba <_Z23initiate_return_processv>:
	PORTD &=~ (1<<PIND6);
}

void initiate_return_process(void)
{
	stop_counter();
 1ba:	0e 94 a3 00 	call	0x146	; 0x146 <_Z12stop_counterv>
 1be:	8f e9       	ldi	r24, 0x9F	; 159
 1c0:	96 e8       	ldi	r25, 0x86	; 134
 1c2:	a1 e0       	ldi	r26, 0x01	; 1
 1c4:	81 50       	subi	r24, 0x01	; 1
 1c6:	90 40       	sbci	r25, 0x00	; 0
 1c8:	a0 40       	sbci	r26, 0x00	; 0
 1ca:	e1 f7       	brne	.-8      	; 0x1c4 <_Z23initiate_return_processv+0xa>
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <_Z23initiate_return_processv+0x14>
 1ce:	00 00       	nop
	_delay_ms(500);
	
	return_coin();
 1d0:	0e 94 50 00 	call	0xa0	; 0xa0 <_Z11return_coinv>
 1d4:	a3 ed       	ldi	r26, 0xD3	; 211
 1d6:	b0 e3       	ldi	r27, 0x30	; 48
 1d8:	11 97       	sbiw	r26, 0x01	; 1
 1da:	f1 f7       	brne	.-4      	; 0x1d8 <_Z23initiate_return_processv+0x1e>
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <_Z23initiate_return_processv+0x24>
 1de:	00 00       	nop
	_delay_ms(50);
	initialise_PWM_coin();
 1e0:	0e 94 5e 00 	call	0xbc	; 0xbc <_Z19initialise_PWM_coinv>
 1e4:	8f e3       	ldi	r24, 0x3F	; 63
 1e6:	9d e0       	ldi	r25, 0x0D	; 13
 1e8:	a3 e0       	ldi	r26, 0x03	; 3
 1ea:	81 50       	subi	r24, 0x01	; 1
 1ec:	90 40       	sbci	r25, 0x00	; 0
 1ee:	a0 40       	sbci	r26, 0x00	; 0
 1f0:	e1 f7       	brne	.-8      	; 0x1ea <_Z23initiate_return_processv+0x30>
 1f2:	00 c0       	rjmp	.+0      	; 0x1f4 <_Z23initiate_return_processv+0x3a>
 1f4:	00 00       	nop
	_delay_ms(1000);////calibrate it further
	stop_PWM_coin();
 1f6:	0e 94 70 00 	call	0xe0	; 0xe0 <_Z13stop_PWM_coinv>
 1fa:	a3 ed       	ldi	r26, 0xD3	; 211
 1fc:	b0 e3       	ldi	r27, 0x30	; 48
 1fe:	11 97       	sbiw	r26, 0x01	; 1
 200:	f1 f7       	brne	.-4      	; 0x1fe <_Z23initiate_return_processv+0x44>
 202:	00 c0       	rjmp	.+0      	; 0x204 <_Z23initiate_return_processv+0x4a>
 204:	00 00       	nop
	_delay_ms(50);
	disable_driver();
 206:	0e 94 49 00 	call	0x92	; 0x92 <_Z14disable_driverv>
}
 20a:	08 95       	ret

0000020c <__vector_9>:
	Send_A_String("parameters Reset");
	_delay_ms(500);
}

ISR(TIMER0_OVF_vect)
{		
 20c:	1f 92       	push	r1
 20e:	0f 92       	push	r0
 210:	0f b6       	in	r0, 0x3f	; 63
 212:	0f 92       	push	r0
 214:	11 24       	eor	r1, r1
 216:	8f 93       	push	r24
 218:	9f 93       	push	r25
	count++;
 21a:	80 91 52 01 	lds	r24, 0x0152
 21e:	8f 5f       	subi	r24, 0xFF	; 255
 220:	80 93 52 01 	sts	0x0152, r24
	if (count==61)
 224:	80 91 52 01 	lds	r24, 0x0152
 228:	8d 33       	cpi	r24, 0x3D	; 61
 22a:	a1 f4       	brne	.+40     	; 0x254 <__vector_9+0x48>
	{
		// 1 second has elapsed
		count=0;
 22c:	10 92 52 01 	sts	0x0152, r1
				
		count1++;
 230:	80 91 51 01 	lds	r24, 0x0151
 234:	8f 5f       	subi	r24, 0xFF	; 255
 236:	80 93 51 01 	sts	0x0151, r24
		
		PORTC ^= (1<<PINC3);
 23a:	95 b3       	in	r25, 0x15	; 21
 23c:	88 e0       	ldi	r24, 0x08	; 8
 23e:	89 27       	eor	r24, r25
 240:	85 bb       	out	0x15, r24	; 21
		
		if (count1>=20)/////// calibrate it further
 242:	80 91 51 01 	lds	r24, 0x0151
 246:	84 31       	cpi	r24, 0x14	; 20
 248:	28 f0       	brcs	.+10     	; 0x254 <__vector_9+0x48>
		{			
			//return coin if not dispatched  
			count1=0;
 24a:	10 92 51 01 	sts	0x0151, r1
			FAIL=1;
 24e:	81 e0       	ldi	r24, 0x01	; 1
 250:	80 93 50 01 	sts	0x0150, r24
		}		
	}
}
 254:	9f 91       	pop	r25
 256:	8f 91       	pop	r24
 258:	0f 90       	pop	r0
 25a:	0f be       	out	0x3f, r0	; 63
 25c:	0f 90       	pop	r0
 25e:	1f 90       	pop	r1
 260:	18 95       	reti

00000262 <_Z10Peek_A_Boov>:
	
	DataDir_MrLCDsCrib=0xFF;
}
void Peek_A_Boo(void)
{
	MrLCDsControl |= 1<<LightSwitch;
 262:	dd 9a       	sbi	0x1b, 5	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 264:	83 e0       	ldi	r24, 0x03	; 3
 266:	8a 95       	dec	r24
 268:	f1 f7       	brne	.-4      	; 0x266 <_Z10Peek_A_Boov+0x4>
 26a:	00 00       	nop
	_delay_us(10);/////CALIBRATE IT FURTHER
	MrLCDsControl &=~  1<<LightSwitch;
 26c:	8b b3       	in	r24, 0x1b	; 27
 26e:	80 7c       	andi	r24, 0xC0	; 192
 270:	8b bb       	out	0x1b, r24	; 27
}
 272:	08 95       	ret

00000274 <_Z21Check_IF_MrLCD_isBusyv>:
	}
}

void Check_IF_MrLCD_isBusy(void)
{
	DataDir_MrLCDsCrib=0;
 274:	17 ba       	out	0x17, r1	; 23
	MrLCDsControl |= 1<<ReadWrite;
 276:	de 9a       	sbi	0x1b, 6	; 27
	MrLCDsControl &=~ 1<<BiPolarMood;
 278:	8b b3       	in	r24, 0x1b	; 27
 27a:	1b ba       	out	0x1b, r1	; 27
	
	while(MrLCDsCrib >= 0x80)
 27c:	c7 9b       	sbis	0x18, 7	; 24
 27e:	04 c0       	rjmp	.+8      	; 0x288 <_Z21Check_IF_MrLCD_isBusyv+0x14>
	{
		Peek_A_Boo();
 280:	0e 94 31 01 	call	0x262	; 0x262 <_Z10Peek_A_Boov>
{
	DataDir_MrLCDsCrib=0;
	MrLCDsControl |= 1<<ReadWrite;
	MrLCDsControl &=~ 1<<BiPolarMood;
	
	while(MrLCDsCrib >= 0x80)
 284:	c7 99       	sbic	0x18, 7	; 24
 286:	fc cf       	rjmp	.-8      	; 0x280 <_Z21Check_IF_MrLCD_isBusyv+0xc>
	{
		Peek_A_Boo();
	}
	
	DataDir_MrLCDsCrib=0xFF;
 288:	8f ef       	ldi	r24, 0xFF	; 255
 28a:	87 bb       	out	0x17, r24	; 23
}
 28c:	08 95       	ret

0000028e <_Z14Send_A_Commandc>:
	MrLCDsControl |= 1<<LightSwitch;
	_delay_us(10);/////CALIBRATE IT FURTHER
	MrLCDsControl &=~  1<<LightSwitch;
}
void Send_A_Command(char command)
{
 28e:	cf 93       	push	r28
 290:	c8 2f       	mov	r28, r24
	Check_IF_MrLCD_isBusy();
 292:	0e 94 3a 01 	call	0x274	; 0x274 <_Z21Check_IF_MrLCD_isBusyv>
	MrLCDsCrib = command;
 296:	c8 bb       	out	0x18, r28	; 24
	MrLCDsControl &=~ (1<<ReadWrite|1<<BiPolarMood);
 298:	8b b3       	in	r24, 0x1b	; 27
 29a:	8f 73       	andi	r24, 0x3F	; 63
 29c:	8b bb       	out	0x1b, r24	; 27
	Peek_A_Boo();
 29e:	0e 94 31 01 	call	0x262	; 0x262 <_Z10Peek_A_Boov>
	MrLCDsCrib = 0;	
 2a2:	18 ba       	out	0x18, r1	; 24
}
 2a4:	cf 91       	pop	r28
 2a6:	08 95       	ret

000002a8 <_Z16Send_A_Characterc>:
void Send_A_Character(char character)
{
 2a8:	cf 93       	push	r28
 2aa:	c8 2f       	mov	r28, r24
	Check_IF_MrLCD_isBusy();
 2ac:	0e 94 3a 01 	call	0x274	; 0x274 <_Z21Check_IF_MrLCD_isBusyv>
	MrLCDsCrib = character;
 2b0:	c8 bb       	out	0x18, r28	; 24
	MrLCDsControl &=~ (1<<ReadWrite);
 2b2:	de 98       	cbi	0x1b, 6	; 27
	MrLCDsControl |= (1<<BiPolarMood);
 2b4:	df 9a       	sbi	0x1b, 7	; 27
	Peek_A_Boo();
 2b6:	0e 94 31 01 	call	0x262	; 0x262 <_Z10Peek_A_Boov>
	MrLCDsCrib = 0;
 2ba:	18 ba       	out	0x18, r1	; 24
}
 2bc:	cf 91       	pop	r28
 2be:	08 95       	ret

000002c0 <_Z13Send_A_StringPc>:
void Send_A_String(char *stringOfCharacters)
{
 2c0:	cf 93       	push	r28
 2c2:	df 93       	push	r29
 2c4:	ec 01       	movw	r28, r24
	while(*stringOfCharacters > 0)
 2c6:	88 81       	ld	r24, Y
 2c8:	88 23       	and	r24, r24
 2ca:	31 f0       	breq	.+12     	; 0x2d8 <_Z13Send_A_StringPc+0x18>
	MrLCDsControl &=~ (1<<ReadWrite);
	MrLCDsControl |= (1<<BiPolarMood);
	Peek_A_Boo();
	MrLCDsCrib = 0;
}
void Send_A_String(char *stringOfCharacters)
 2cc:	21 96       	adiw	r28, 0x01	; 1
{
	while(*stringOfCharacters > 0)
	{
		Send_A_Character(*stringOfCharacters++);
 2ce:	0e 94 54 01 	call	0x2a8	; 0x2a8 <_Z16Send_A_Characterc>
	Peek_A_Boo();
	MrLCDsCrib = 0;
}
void Send_A_String(char *stringOfCharacters)
{
	while(*stringOfCharacters > 0)
 2d2:	89 91       	ld	r24, Y+
 2d4:	88 23       	and	r24, r24
 2d6:	d9 f7       	brne	.-10     	; 0x2ce <_Z13Send_A_StringPc+0xe>
	{
		Send_A_Character(*stringOfCharacters++);
		//_delay_ms(10);
	}
}
 2d8:	df 91       	pop	r29
 2da:	cf 91       	pop	r28
 2dc:	08 95       	ret

000002de <_Z15resetParametersv>:

}

void resetParameters(void)
{
	count=0;  //for interrupt generation
 2de:	10 92 52 01 	sts	0x0152, r1
	count1=0; //10 sec delay initializer
 2e2:	10 92 51 01 	sts	0x0151, r1
	FAIL = 0;
 2e6:	10 92 50 01 	sts	0x0150, r1

	p = 0;
 2ea:	10 92 4f 01 	sts	0x014F, r1
	kick = 0;
 2ee:	10 92 4e 01 	sts	0x014E, r1
	STOCK = 0;
 2f2:	10 92 4d 01 	sts	0x014D, r1
	
	coin_10RS = 0;
 2f6:	10 92 4c 01 	sts	0x014C, r1
	RS10_coin_no = 0;
 2fa:	10 92 4b 01 	sts	0x014B, r1
	coin_count = 0;
 2fe:	10 92 4a 01 	sts	0x014A, r1

	coin_05RS = 0;
 302:	10 92 49 01 	sts	0x0149, r1
	RS05_coin_no = 0;
 306:	10 92 48 01 	sts	0x0148, r1

	money = 0;
 30a:	10 92 47 01 	sts	0x0147, r1
 30e:	10 92 46 01 	sts	0x0146, r1

	pressed=0;
 312:	10 92 45 01 	sts	0x0145, r1
 316:	10 92 44 01 	sts	0x0144, r1
	pressed_1=0;
 31a:	10 92 43 01 	sts	0x0143, r1
 31e:	10 92 42 01 	sts	0x0142, r1
	pressed_2=0;
 322:	10 92 41 01 	sts	0x0141, r1
 326:	10 92 40 01 	sts	0x0140, r1

	metal_touch=0;
 32a:	10 92 3f 01 	sts	0x013F, r1
 32e:	10 92 3e 01 	sts	0x013E, r1
	dispatched=0;
 332:	10 92 3d 01 	sts	0x013D, r1
 336:	10 92 3c 01 	sts	0x013C, r1
	successful=0;
 33a:	10 92 3b 01 	sts	0x013B, r1
 33e:	10 92 3a 01 	sts	0x013A, r1
	aagaya=0;
 342:	10 92 39 01 	sts	0x0139, r1
 346:	10 92 38 01 	sts	0x0138, r1
	
	refresh = 0;
 34a:	10 92 37 01 	sts	0x0137, r1
 34e:	10 92 36 01 	sts	0x0136, r1
	refresh2 = 0;
 352:	10 92 35 01 	sts	0x0135, r1
 356:	10 92 34 01 	sts	0x0134, r1
	
	stop_counter();
 35a:	0e 94 a3 00 	call	0x146	; 0x146 <_Z12stop_counterv>
	PORTC = 0;
 35e:	15 ba       	out	0x15, r1	; 21
	
	Send_A_Command(0x01);//clrscr();
 360:	81 e0       	ldi	r24, 0x01	; 1
 362:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 366:	83 ef       	ldi	r24, 0xF3	; 243
 368:	91 e0       	ldi	r25, 0x01	; 1
 36a:	01 97       	sbiw	r24, 0x01	; 1
 36c:	f1 f7       	brne	.-4      	; 0x36a <_Z15resetParametersv+0x8c>
 36e:	00 c0       	rjmp	.+0      	; 0x370 <_Z15resetParametersv+0x92>
 370:	00 00       	nop
	_delay_ms(2);
	Send_A_String("parameters Reset");
 372:	80 e6       	ldi	r24, 0x60	; 96
 374:	90 e0       	ldi	r25, 0x00	; 0
 376:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
 37a:	8f e9       	ldi	r24, 0x9F	; 159
 37c:	96 e8       	ldi	r25, 0x86	; 134
 37e:	a1 e0       	ldi	r26, 0x01	; 1
 380:	81 50       	subi	r24, 0x01	; 1
 382:	90 40       	sbci	r25, 0x00	; 0
 384:	a0 40       	sbci	r26, 0x00	; 0
 386:	e1 f7       	brne	.-8      	; 0x380 <_Z15resetParametersv+0xa2>
 388:	00 c0       	rjmp	.+0      	; 0x38a <_Z15resetParametersv+0xac>
 38a:	00 00       	nop
	_delay_ms(500);
}
 38c:	08 95       	ret

0000038e <_Z11CHECK_STOCKv>:
// 		}		
	}		
}
void CHECK_STOCK(void)
{
	Send_A_Command(0x01);//clrscr();
 38e:	81 e0       	ldi	r24, 0x01	; 1
 390:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 394:	83 ef       	ldi	r24, 0xF3	; 243
 396:	91 e0       	ldi	r25, 0x01	; 1
 398:	01 97       	sbiw	r24, 0x01	; 1
 39a:	f1 f7       	brne	.-4      	; 0x398 <_Z11CHECK_STOCKv+0xa>
 39c:	00 c0       	rjmp	.+0      	; 0x39e <_Z11CHECK_STOCKv+0x10>
 39e:	00 00       	nop
	_delay_ms(2);
	Send_A_String("checking stock");
 3a0:	81 e7       	ldi	r24, 0x71	; 113
 3a2:	90 e0       	ldi	r25, 0x00	; 0
 3a4:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
	
	while(5)
	{
		if(bit_is_set(PINA,3)) //empty
 3a8:	cb 9b       	sbis	0x19, 3	; 25
 3aa:	16 c0       	rjmp	.+44     	; 0x3d8 <_Z11CHECK_STOCKv+0x4a>
		{
			STOCK = 1;
 3ac:	81 e0       	ldi	r24, 0x01	; 1
 3ae:	80 93 4d 01 	sts	0x014D, r24
			
			Send_A_Command(0x01);//clrscr();
 3b2:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 3b6:	a3 ef       	ldi	r26, 0xF3	; 243
 3b8:	b1 e0       	ldi	r27, 0x01	; 1
 3ba:	11 97       	sbiw	r26, 0x01	; 1
 3bc:	f1 f7       	brne	.-4      	; 0x3ba <_Z11CHECK_STOCKv+0x2c>
 3be:	00 c0       	rjmp	.+0      	; 0x3c0 <_Z11CHECK_STOCKv+0x32>
 3c0:	00 00       	nop
			_delay_ms(2);
			Send_A_String("stock present");
 3c2:	80 e8       	ldi	r24, 0x80	; 128
 3c4:	90 e0       	ldi	r25, 0x00	; 0
 3c6:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
 3ca:	87 ea       	ldi	r24, 0xA7	; 167
 3cc:	91 e6       	ldi	r25, 0x61	; 97
 3ce:	01 97       	sbiw	r24, 0x01	; 1
 3d0:	f1 f7       	brne	.-4      	; 0x3ce <_Z11CHECK_STOCKv+0x40>
 3d2:	00 c0       	rjmp	.+0      	; 0x3d4 <_Z11CHECK_STOCKv+0x46>
 3d4:	00 00       	nop
 3d6:	08 95       	ret
			_delay_ms(100);
			
			break;
		}
		else
		if(bit_is_clear(PINA,3)) //available
 3d8:	cb 99       	sbic	0x19, 3	; 25
 3da:	e6 cf       	rjmp	.-52     	; 0x3a8 <_Z11CHECK_STOCKv+0x1a>
		{
			STOCK = 0;
 3dc:	10 92 4d 01 	sts	0x014D, r1
			
			Send_A_Command(0x01);//clrscr();
 3e0:	81 e0       	ldi	r24, 0x01	; 1
 3e2:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 3e6:	a3 ef       	ldi	r26, 0xF3	; 243
 3e8:	b1 e0       	ldi	r27, 0x01	; 1
 3ea:	11 97       	sbiw	r26, 0x01	; 1
 3ec:	f1 f7       	brne	.-4      	; 0x3ea <_Z11CHECK_STOCKv+0x5c>
 3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <_Z11CHECK_STOCKv+0x62>
 3f0:	00 00       	nop
			_delay_ms(2);
			Send_A_String("out of stock");
 3f2:	8e e8       	ldi	r24, 0x8E	; 142
 3f4:	90 e0       	ldi	r25, 0x00	; 0
 3f6:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
 3fa:	8f e3       	ldi	r24, 0x3F	; 63
 3fc:	9d e0       	ldi	r25, 0x0D	; 13
 3fe:	a3 e0       	ldi	r26, 0x03	; 3
 400:	81 50       	subi	r24, 0x01	; 1
 402:	90 40       	sbci	r25, 0x00	; 0
 404:	a0 40       	sbci	r26, 0x00	; 0
 406:	e1 f7       	brne	.-8      	; 0x400 <_Z11CHECK_STOCKv+0x72>
 408:	00 c0       	rjmp	.+0      	; 0x40a <_Z11CHECK_STOCKv+0x7c>
 40a:	00 00       	nop
			_delay_ms(1000);
			
			PORTC |= (1<<PINC7);
 40c:	af 9a       	sbi	0x15, 7	; 21
 40e:	08 95       	ret

00000410 <_Z19check_IF_successfulv>:
}
void check_IF_successful(void)
{
	while(4)
	{
		if (FAIL == 1)
 410:	80 91 50 01 	lds	r24, 0x0150
 414:	81 30       	cpi	r24, 0x01	; 1
 416:	29 f4       	brne	.+10     	; 0x422 <_Z19check_IF_successfulv+0x12>
		{
			successful=0;
 418:	10 92 3b 01 	sts	0x013B, r1
 41c:	10 92 3a 01 	sts	0x013A, r1
			break;
 420:	08 95       	ret
		}
		else
		if (bit_is_set(PINA,0))
 422:	c8 9b       	sbis	0x19, 0	; 25
 424:	f5 cf       	rjmp	.-22     	; 0x410 <_Z19check_IF_successfulv>
		{
			dispatched = 1;
 426:	81 e0       	ldi	r24, 0x01	; 1
 428:	90 e0       	ldi	r25, 0x00	; 0
 42a:	90 93 3d 01 	sts	0x013D, r25
 42e:	80 93 3c 01 	sts	0x013C, r24
			successful = 1;
 432:	90 93 3b 01 	sts	0x013B, r25
 436:	80 93 3a 01 	sts	0x013A, r24
			
			Send_A_Command(0x01);//clrscr();
 43a:	81 e0       	ldi	r24, 0x01	; 1
 43c:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 440:	83 ef       	ldi	r24, 0xF3	; 243
 442:	91 e0       	ldi	r25, 0x01	; 1
 444:	01 97       	sbiw	r24, 0x01	; 1
 446:	f1 f7       	brne	.-4      	; 0x444 <_Z19check_IF_successfulv+0x34>
 448:	00 c0       	rjmp	.+0      	; 0x44a <_Z19check_IF_successfulv+0x3a>
 44a:	00 00       	nop
			_delay_ms(2);
			Send_A_String("please collect!!");
 44c:	8b e9       	ldi	r24, 0x9B	; 155
 44e:	90 e0       	ldi	r25, 0x00	; 0
 450:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
 454:	08 95       	ret

00000456 <_Z15vend_STATIONERYv>:
			if (pressed==1) pressed=0;		
		}
	}
}
void vend_STATIONERY(void)
{
 456:	0f 93       	push	r16
 458:	1f 93       	push	r17
 45a:	cf 93       	push	r28
 45c:	df 93       	push	r29
	while(3)
	{
		Send_A_Command(0x01);//clrscr();
		_delay_ms(2);
		Send_A_String("here we go");
 45e:	cc ea       	ldi	r28, 0xAC	; 172
 460:	d0 e0       	ldi	r29, 0x00	; 0
				
		if (bit_is_set(PINA,0))
		{
			Send_A_Command(0x01);//clrscr();
			_delay_ms(2);
			Send_A_String("pick up first");
 462:	07 eb       	ldi	r16, 0xB7	; 183
 464:	10 e0       	ldi	r17, 0x00	; 0
}
void vend_STATIONERY(void)
{
	while(3)
	{
		Send_A_Command(0x01);//clrscr();
 466:	81 e0       	ldi	r24, 0x01	; 1
 468:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 46c:	83 ef       	ldi	r24, 0xF3	; 243
 46e:	91 e0       	ldi	r25, 0x01	; 1
 470:	01 97       	sbiw	r24, 0x01	; 1
 472:	f1 f7       	brne	.-4      	; 0x470 <__stack+0x11>
 474:	00 c0       	rjmp	.+0      	; 0x476 <__stack+0x17>
 476:	00 00       	nop
		_delay_ms(2);
		Send_A_String("here we go");
 478:	ce 01       	movw	r24, r28
 47a:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
 47e:	8f e3       	ldi	r24, 0x3F	; 63
 480:	9d e0       	ldi	r25, 0x0D	; 13
 482:	a3 e0       	ldi	r26, 0x03	; 3
 484:	81 50       	subi	r24, 0x01	; 1
 486:	90 40       	sbci	r25, 0x00	; 0
 488:	a0 40       	sbci	r26, 0x00	; 0
 48a:	e1 f7       	brne	.-8      	; 0x484 <__stack+0x25>
 48c:	00 c0       	rjmp	.+0      	; 0x48e <__stack+0x2f>
 48e:	00 00       	nop
		
		_delay_ms(1000);
				
		if (bit_is_set(PINA,0))
 490:	c8 9b       	sbis	0x19, 0	; 25
 492:	0d c0       	rjmp	.+26     	; 0x4ae <__stack+0x4f>
		{
			Send_A_Command(0x01);//clrscr();
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 49a:	a3 ef       	ldi	r26, 0xF3	; 243
 49c:	b1 e0       	ldi	r27, 0x01	; 1
 49e:	11 97       	sbiw	r26, 0x01	; 1
 4a0:	f1 f7       	brne	.-4      	; 0x49e <__stack+0x3f>
 4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <__stack+0x45>
 4a4:	00 00       	nop
			_delay_ms(2);
			Send_A_String("pick up first");
 4a6:	c8 01       	movw	r24, r16
 4a8:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
 4ac:	dc cf       	rjmp	.-72     	; 0x466 <__stack+0x7>
		}
		else
		if (bit_is_clear(PINA,0))
 4ae:	89 b3       	in	r24, 0x19	; 25
 4b0:	80 fd       	sbrc	r24, 0
 4b2:	d9 cf       	rjmp	.-78     	; 0x466 <__stack+0x7>
		{
			sw_debounce_released();
			//dispatched=1;
			dispatch_parameter();
 4b4:	0e 94 7c 00 	call	0xf8	; 0xf8 <_Z18dispatch_parameterv>
			initialise_PWM_dispatch();
 4b8:	0e 94 66 00 	call	0xcc	; 0xcc <_Z23initialise_PWM_dispatchv>
			
			Send_A_Command(0x01);//clrscr();
 4bc:	81 e0       	ldi	r24, 0x01	; 1
 4be:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 4c2:	83 ef       	ldi	r24, 0xF3	; 243
 4c4:	91 e0       	ldi	r25, 0x01	; 1
 4c6:	01 97       	sbiw	r24, 0x01	; 1
 4c8:	f1 f7       	brne	.-4      	; 0x4c6 <__stack+0x67>
 4ca:	00 c0       	rjmp	.+0      	; 0x4cc <__stack+0x6d>
 4cc:	00 00       	nop
			_delay_ms(2);
			Send_A_String("please wait");
 4ce:	85 ec       	ldi	r24, 0xC5	; 197
 4d0:	90 e0       	ldi	r25, 0x00	; 0
 4d2:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
			
			PORTC |= (1<<PINC5);
 4d6:	ad 9a       	sbi	0x15, 5	; 21
		}
		
		
		//////ask to pick the package first
	}
}
 4d8:	df 91       	pop	r29
 4da:	cf 91       	pop	r28
 4dc:	1f 91       	pop	r17
 4de:	0f 91       	pop	r16
 4e0:	08 95       	ret

000004e2 <_Z18Send_A_String_instPc>:
		Send_A_Character(*stringOfCharacters++);
		//_delay_ms(10);
	}
}
void Send_A_String_inst(char *stringOfCharacters)
{
 4e2:	cf 93       	push	r28
 4e4:	df 93       	push	r29
 4e6:	ec 01       	movw	r28, r24
	while(*stringOfCharacters > 0)
 4e8:	88 81       	ld	r24, Y
 4ea:	88 23       	and	r24, r24
 4ec:	31 f0       	breq	.+12     	; 0x4fa <_Z18Send_A_String_instPc+0x18>
	{
		Send_A_Character(*stringOfCharacters++);
		//_delay_ms(10);
	}
}
void Send_A_String_inst(char *stringOfCharacters)
 4ee:	21 96       	adiw	r28, 0x01	; 1
{
	while(*stringOfCharacters > 0)
	{
		Send_A_Character(*stringOfCharacters++);
 4f0:	0e 94 54 01 	call	0x2a8	; 0x2a8 <_Z16Send_A_Characterc>
		//_delay_ms(10);
	}
}
void Send_A_String_inst(char *stringOfCharacters)
{
	while(*stringOfCharacters > 0)
 4f4:	89 91       	ld	r24, Y+
 4f6:	88 23       	and	r24, r24
 4f8:	d9 f7       	brne	.-10     	; 0x4f0 <_Z18Send_A_String_instPc+0xe>
	{
		Send_A_Character(*stringOfCharacters++);
	}
}
 4fa:	df 91       	pop	r29
 4fc:	cf 91       	pop	r28
 4fe:	08 95       	ret

00000500 <_Z11detect_coinv>:
	_delay_ms(1);
	TCNT0=0;
}

void detect_coin(void)
{
 500:	0f 93       	push	r16
 502:	1f 93       	push	r17
 504:	cf 93       	push	r28
 506:	df 93       	push	r29
				{
					refresh2 = 0;
				
					Send_A_Command(0x01);//clrscr();
					_delay_ms(2);
					Send_A_String_inst(" AUSTIN Pvt Ltd.");
 508:	cf ed       	ldi	r28, 0xDF	; 223
 50a:	d0 e0       	ldi	r29, 0x00	; 0
					
					Send_A_Command(0xC0);//next line;
					_delay_ms(2);
					Send_A_String_inst("Plz Insert Rs 10");
 50c:	00 ef       	ldi	r16, 0xF0	; 240
 50e:	10 e0       	ldi	r17, 0x00	; 0

void detect_coin(void)
{
	while(2)
	{		
		if (bit_is_set(PINA,2))
 510:	ca 9b       	sbis	0x19, 2	; 25
 512:	27 c0       	rjmp	.+78     	; 0x562 <_Z11detect_coinv+0x62>
		{
			if (pressed == 0)
 514:	80 91 44 01 	lds	r24, 0x0144
 518:	90 91 45 01 	lds	r25, 0x0145
 51c:	00 97       	sbiw	r24, 0x00	; 0
 51e:	c1 f7       	brne	.-16     	; 0x510 <_Z11detect_coinv+0x10>
			{
				pressed = 1;
 520:	81 e0       	ldi	r24, 0x01	; 1
 522:	90 e0       	ldi	r25, 0x00	; 0
 524:	90 93 45 01 	sts	0x0145, r25
 528:	80 93 44 01 	sts	0x0144, r24
				money = 10;
 52c:	8a e0       	ldi	r24, 0x0A	; 10
 52e:	90 e0       	ldi	r25, 0x00	; 0
 530:	90 93 47 01 	sts	0x0147, r25
 534:	80 93 46 01 	sts	0x0146, r24
				PORTC |= (1<<PINC4);
 538:	ac 9a       	sbi	0x15, 4	; 21
				initialise_counter();
 53a:	0e 94 9b 00 	call	0x136	; 0x136 <_Z18initialise_counterv>
				
				if (STOCK == 1)
 53e:	80 91 4d 01 	lds	r24, 0x014D
 542:	81 30       	cpi	r24, 0x01	; 1
 544:	09 f0       	breq	.+2      	; 0x548 <_Z11detect_coinv+0x48>
 546:	58 c0       	rjmp	.+176    	; 0x5f8 <_Z11detect_coinv+0xf8>
				{
					Send_A_Command(0x01);//clrscr();
 548:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 54c:	83 ef       	ldi	r24, 0xF3	; 243
 54e:	91 e0       	ldi	r25, 0x01	; 1
 550:	01 97       	sbiw	r24, 0x01	; 1
 552:	f1 f7       	brne	.-4      	; 0x550 <_Z11detect_coinv+0x50>
 554:	00 c0       	rjmp	.+0      	; 0x556 <_Z11detect_coinv+0x56>
 556:	00 00       	nop
					_delay_ms(2);
					Send_A_String("coin accepted");
 558:	81 ed       	ldi	r24, 0xD1	; 209
 55a:	90 e0       	ldi	r25, 0x00	; 0
 55c:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
					break;
 560:	4b c0       	rjmp	.+150    	; 0x5f8 <_Z11detect_coinv+0xf8>
				break;			
			}			
		}	
		
		else
		if(bit_is_clear(PINA,2))
 562:	ca 99       	sbic	0x19, 2	; 25
 564:	d5 cf       	rjmp	.-86     	; 0x510 <_Z11detect_coinv+0x10>
		{	
			refresh++;
 566:	80 91 36 01 	lds	r24, 0x0136
 56a:	90 91 37 01 	lds	r25, 0x0137
 56e:	01 96       	adiw	r24, 0x01	; 1
 570:	90 93 37 01 	sts	0x0137, r25
 574:	80 93 36 01 	sts	0x0136, r24
			if (refresh >= 10000)
 578:	27 e2       	ldi	r18, 0x27	; 39
 57a:	80 31       	cpi	r24, 0x10	; 16
 57c:	92 07       	cpc	r25, r18
 57e:	7c f1       	brlt	.+94     	; 0x5de <_Z11detect_coinv+0xde>
			{
				refresh = 0;
 580:	10 92 37 01 	sts	0x0137, r1
 584:	10 92 36 01 	sts	0x0136, r1
				
				refresh2++;
 588:	80 91 34 01 	lds	r24, 0x0134
 58c:	90 91 35 01 	lds	r25, 0x0135
 590:	01 96       	adiw	r24, 0x01	; 1
 592:	90 93 35 01 	sts	0x0135, r25
 596:	80 93 34 01 	sts	0x0134, r24
				
				if (refresh2 >= 10000)
 59a:	27 e2       	ldi	r18, 0x27	; 39
 59c:	80 31       	cpi	r24, 0x10	; 16
 59e:	92 07       	cpc	r25, r18
 5a0:	0c f4       	brge	.+2      	; 0x5a4 <_Z11detect_coinv+0xa4>
 5a2:	b6 cf       	rjmp	.-148    	; 0x510 <_Z11detect_coinv+0x10>
				{
					refresh2 = 0;
 5a4:	10 92 35 01 	sts	0x0135, r1
 5a8:	10 92 34 01 	sts	0x0134, r1
				
					Send_A_Command(0x01);//clrscr();
 5ac:	81 e0       	ldi	r24, 0x01	; 1
 5ae:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 5b2:	83 ef       	ldi	r24, 0xF3	; 243
 5b4:	91 e0       	ldi	r25, 0x01	; 1
 5b6:	01 97       	sbiw	r24, 0x01	; 1
 5b8:	f1 f7       	brne	.-4      	; 0x5b6 <_Z11detect_coinv+0xb6>
 5ba:	00 c0       	rjmp	.+0      	; 0x5bc <_Z11detect_coinv+0xbc>
 5bc:	00 00       	nop
					_delay_ms(2);
					Send_A_String_inst(" AUSTIN Pvt Ltd.");
 5be:	ce 01       	movw	r24, r28
 5c0:	0e 94 71 02 	call	0x4e2	; 0x4e2 <_Z18Send_A_String_instPc>
					
					Send_A_Command(0xC0);//next line;
 5c4:	80 ec       	ldi	r24, 0xC0	; 192
 5c6:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 5ca:	83 ef       	ldi	r24, 0xF3	; 243
 5cc:	91 e0       	ldi	r25, 0x01	; 1
 5ce:	01 97       	sbiw	r24, 0x01	; 1
 5d0:	f1 f7       	brne	.-4      	; 0x5ce <_Z11detect_coinv+0xce>
 5d2:	00 c0       	rjmp	.+0      	; 0x5d4 <_Z11detect_coinv+0xd4>
 5d4:	00 00       	nop
					_delay_ms(2);
					Send_A_String_inst("Plz Insert Rs 10");
 5d6:	c8 01       	movw	r24, r16
 5d8:	0e 94 71 02 	call	0x4e2	; 0x4e2 <_Z18Send_A_String_instPc>
 5dc:	99 cf       	rjmp	.-206    	; 0x510 <_Z11detect_coinv+0x10>
				}							
			}
			else		
			if (pressed==1) pressed=0;		
 5de:	80 91 44 01 	lds	r24, 0x0144
 5e2:	90 91 45 01 	lds	r25, 0x0145
 5e6:	81 30       	cpi	r24, 0x01	; 1
 5e8:	91 05       	cpc	r25, r1
 5ea:	09 f0       	breq	.+2      	; 0x5ee <_Z11detect_coinv+0xee>
 5ec:	91 cf       	rjmp	.-222    	; 0x510 <_Z11detect_coinv+0x10>
 5ee:	10 92 45 01 	sts	0x0145, r1
 5f2:	10 92 44 01 	sts	0x0144, r1
 5f6:	8c cf       	rjmp	.-232    	; 0x510 <_Z11detect_coinv+0x10>
		}
	}
}
 5f8:	df 91       	pop	r29
 5fa:	cf 91       	pop	r28
 5fc:	1f 91       	pop	r17
 5fe:	0f 91       	pop	r16
 600:	08 95       	ret

00000602 <main>:
int refresh = 0;
int refresh2 = 0;

int main(void)
{
	DDRA = 0b11111111;
 602:	cf ef       	ldi	r28, 0xFF	; 255
 604:	ca bb       	out	0x1a, r28	; 26
	DDRC = 0xFF;
 606:	c4 bb       	out	0x14, r28	; 20
	DDRD = 0b11111100;
 608:	8c ef       	ldi	r24, 0xFC	; 252
 60a:	81 bb       	out	0x11, r24	; 17
	DataDir_MrLCDsControl |= (1<<LightSwitch) | (1<<ReadWrite) | (1<<BiPolarMood);	
 60c:	8a b3       	in	r24, 0x1a	; 26
 60e:	80 6e       	ori	r24, 0xE0	; 224
 610:	8a bb       	out	0x1a, r24	; 26
	
	PORTA |= (1<<PINA0) | (1<<PINA1) | (1<<PINA2) | (1<<PINA3); /*| (1<<PINA4); */
 612:	8b b3       	in	r24, 0x1b	; 27
 614:	8f 60       	ori	r24, 0x0F	; 15
 616:	8b bb       	out	0x1b, r24	; 27
	PORTC = 0x00;
 618:	15 ba       	out	0x15, r1	; 21
	PORTD = 0b00000011;
 61a:	83 e0       	ldi	r24, 0x03	; 3
 61c:	82 bb       	out	0x12, r24	; 18
	
	DDRA |= (1<<PINA4);
 61e:	d4 9a       	sbi	0x1a, 4	; 26
	PORTA |=(1<<PINA4);
 620:	dc 9a       	sbi	0x1b, 4	; 27

	//sei();	
		
	PORTC |= (1<<PINC0);
 622:	a8 9a       	sbi	0x15, 0	; 21
	initialise_PWM();
 624:	0e 94 53 00 	call	0xa6	; 0xa6 <_Z14initialise_PWMv>
 628:	85 ea       	ldi	r24, 0xA5	; 165
 62a:	9e e0       	ldi	r25, 0x0E	; 14
 62c:	01 97       	sbiw	r24, 0x01	; 1
 62e:	f1 f7       	brne	.-4      	; 0x62c <main+0x2a>
 630:	00 c0       	rjmp	.+0      	; 0x632 <main+0x30>
 632:	00 00       	nop
	
	_delay_ms(15);
	Send_A_Command(0x01);//clrscr();
 634:	81 e0       	ldi	r24, 0x01	; 1
 636:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 63a:	a3 ef       	ldi	r26, 0xF3	; 243
 63c:	b1 e0       	ldi	r27, 0x01	; 1
 63e:	11 97       	sbiw	r26, 0x01	; 1
 640:	f1 f7       	brne	.-4      	; 0x63e <main+0x3c>
 642:	00 c0       	rjmp	.+0      	; 0x644 <main+0x42>
 644:	00 00       	nop
	_delay_ms(2);
	Send_A_Command(0x38);
 646:	88 e3       	ldi	r24, 0x38	; 56
 648:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 64c:	b0 e1       	ldi	r27, 0x10	; 16
 64e:	ba 95       	dec	r27
 650:	f1 f7       	brne	.-4      	; 0x64e <main+0x4c>
 652:	00 c0       	rjmp	.+0      	; 0x654 <main+0x52>
	_delay_us(50);
	Send_A_Command(0b00001100);
 654:	8c e0       	ldi	r24, 0x0C	; 12
 656:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 65a:	80 e1       	ldi	r24, 0x10	; 16
 65c:	8a 95       	dec	r24
 65e:	f1 f7       	brne	.-4      	; 0x65c <main+0x5a>
 660:	00 c0       	rjmp	.+0      	; 0x662 <main+0x60>
	_delay_us(50);
	
	PORTC = 0xFF;
 662:	c5 bb       	out	0x15, r28	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 664:	8f e9       	ldi	r24, 0x9F	; 159
 666:	96 e8       	ldi	r25, 0x86	; 134
 668:	a1 e0       	ldi	r26, 0x01	; 1
 66a:	81 50       	subi	r24, 0x01	; 1
 66c:	90 40       	sbci	r25, 0x00	; 0
 66e:	a0 40       	sbci	r26, 0x00	; 0
 670:	e1 f7       	brne	.-8      	; 0x66a <main+0x68>
 672:	00 c0       	rjmp	.+0      	; 0x674 <main+0x72>
 674:	00 00       	nop
	_delay_ms(500);
	PORTC = 0;
 676:	15 ba       	out	0x15, r1	; 21
 678:	8f e9       	ldi	r24, 0x9F	; 159
 67a:	96 e8       	ldi	r25, 0x86	; 134
 67c:	a1 e0       	ldi	r26, 0x01	; 1
 67e:	81 50       	subi	r24, 0x01	; 1
 680:	90 40       	sbci	r25, 0x00	; 0
 682:	a0 40       	sbci	r26, 0x00	; 0
 684:	e1 f7       	brne	.-8      	; 0x67e <main+0x7c>
 686:	00 c0       	rjmp	.+0      	; 0x688 <main+0x86>
 688:	00 00       	nop
		
		CHECK_STOCK();		
		
		Send_A_Command(0x01);//clrscr();
		_delay_ms(2);
		Send_A_String(" AUSTIN Pvt Ltd.");
 68a:	cf ed       	ldi	r28, 0xDF	; 223
 68c:	d0 e0       	ldi	r29, 0x00	; 0
		
		Send_A_Command(0xC0);//next line;
		_delay_ms(2);
		Send_A_String("Plz Insert Rs 10");	
 68e:	00 ef       	ldi	r16, 0xF0	; 240
 690:	10 e0       	ldi	r17, 0x00	; 0
			else
			if (STOCK == 0)
			{
				Send_A_Command(0x01);//clrscr();
				_delay_ms(2);
				Send_A_String("Plz Collect Coin");
 692:	0f 2e       	mov	r0, r31
 694:	f1 e0       	ldi	r31, 0x01	; 1
 696:	ef 2e       	mov	r14, r31
 698:	f1 e0       	ldi	r31, 0x01	; 1
 69a:	ff 2e       	mov	r15, r31
 69c:	f0 2d       	mov	r31, r0
				
				Send_A_Command(0xC0);//next line;
				_delay_ms(2);
				Send_A_String("  OUT OF STOCK  ");
 69e:	0f 2e       	mov	r0, r31
 6a0:	f2 e2       	ldi	r31, 0x22	; 34
 6a2:	cf 2e       	mov	r12, r31
 6a4:	f1 e0       	ldi	r31, 0x01	; 1
 6a6:	df 2e       	mov	r13, r31
 6a8:	f0 2d       	mov	r31, r0
					_delay_ms(2);
					Send_A_String("Plz Collect Coin");
					
					Send_A_Command(0xC0);//next line;
					_delay_ms(2);
					Send_A_String("ERROR-TRY AGAIN");
 6aa:	0f 2e       	mov	r0, r31
 6ac:	f2 e1       	ldi	r31, 0x12	; 18
 6ae:	af 2e       	mov	r10, r31
 6b0:	f1 e0       	ldi	r31, 0x01	; 1
 6b2:	bf 2e       	mov	r11, r31
 6b4:	f0 2d       	mov	r31, r0
				
				check_IF_successful();
				
				if (successful == 1)
				{
					OCR1B = 4500;
 6b6:	0f 2e       	mov	r0, r31
 6b8:	f4 e9       	ldi	r31, 0x94	; 148
 6ba:	8f 2e       	mov	r8, r31
 6bc:	f1 e1       	ldi	r31, 0x11	; 17
 6be:	9f 2e       	mov	r9, r31
 6c0:	f0 2d       	mov	r31, r0
	PORTC = 0;
	_delay_ms(500);
	
	while (1)
	{			
		resetParameters();
 6c2:	0e 94 6f 01 	call	0x2de	; 0x2de <_Z15resetParametersv>
		
		CHECK_STOCK();		
 6c6:	0e 94 c7 01 	call	0x38e	; 0x38e <_Z11CHECK_STOCKv>
		
		Send_A_Command(0x01);//clrscr();
 6ca:	81 e0       	ldi	r24, 0x01	; 1
 6cc:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 6d0:	a3 ef       	ldi	r26, 0xF3	; 243
 6d2:	b1 e0       	ldi	r27, 0x01	; 1
 6d4:	11 97       	sbiw	r26, 0x01	; 1
 6d6:	f1 f7       	brne	.-4      	; 0x6d4 <main+0xd2>
 6d8:	00 c0       	rjmp	.+0      	; 0x6da <main+0xd8>
 6da:	00 00       	nop
		_delay_ms(2);
		Send_A_String(" AUSTIN Pvt Ltd.");
 6dc:	ce 01       	movw	r24, r28
 6de:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
		
		Send_A_Command(0xC0);//next line;
 6e2:	80 ec       	ldi	r24, 0xC0	; 192
 6e4:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 6e8:	83 ef       	ldi	r24, 0xF3	; 243
 6ea:	91 e0       	ldi	r25, 0x01	; 1
 6ec:	01 97       	sbiw	r24, 0x01	; 1
 6ee:	f1 f7       	brne	.-4      	; 0x6ec <main+0xea>
 6f0:	00 c0       	rjmp	.+0      	; 0x6f2 <main+0xf0>
 6f2:	00 00       	nop
		_delay_ms(2);
		Send_A_String("Plz Insert Rs 10");	
 6f4:	c8 01       	movw	r24, r16
 6f6:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
				
		detect_coin();
 6fa:	0e 94 80 02 	call	0x500	; 0x500 <_Z11detect_coinv>
		
		if (money==10)
 6fe:	80 91 46 01 	lds	r24, 0x0146
 702:	90 91 47 01 	lds	r25, 0x0147
 706:	8a 30       	cpi	r24, 0x0A	; 10
 708:	91 05       	cpc	r25, r1
 70a:	09 f0       	breq	.+2      	; 0x70e <main+0x10c>
 70c:	74 c0       	rjmp	.+232    	; 0x7f6 <main+0x1f4>
		{
			//PORTC |= (1<<PINC3);
			if (STOCK == 1)
 70e:	80 91 4d 01 	lds	r24, 0x014D
 712:	81 30       	cpi	r24, 0x01	; 1
 714:	09 f0       	breq	.+2      	; 0x718 <main+0x116>
 716:	48 c0       	rjmp	.+144    	; 0x7a8 <main+0x1a6>
			{
				vend_STATIONERY();
 718:	0e 94 2b 02 	call	0x456	; 0x456 <_Z15vend_STATIONERYv>
				
				check_IF_successful();
 71c:	0e 94 08 02 	call	0x410	; 0x410 <_Z19check_IF_successfulv>
				
				if (successful == 1)
 720:	80 91 3a 01 	lds	r24, 0x013A
 724:	90 91 3b 01 	lds	r25, 0x013B
 728:	81 30       	cpi	r24, 0x01	; 1
 72a:	91 05       	cpc	r25, r1
 72c:	91 f4       	brne	.+36     	; 0x752 <main+0x150>
				{
					OCR1B = 4500;
 72e:	99 bc       	out	0x29, r9	; 41
 730:	88 bc       	out	0x28, r8	; 40
 732:	8f e7       	ldi	r24, 0x7F	; 127
 734:	98 e3       	ldi	r25, 0x38	; 56
 736:	a1 e0       	ldi	r26, 0x01	; 1
 738:	81 50       	subi	r24, 0x01	; 1
 73a:	90 40       	sbci	r25, 0x00	; 0
 73c:	a0 40       	sbci	r26, 0x00	; 0
 73e:	e1 f7       	brne	.-8      	; 0x738 <main+0x136>
 740:	00 c0       	rjmp	.+0      	; 0x742 <main+0x140>
 742:	00 00       	nop
					_delay_ms(400);//ms 1000 was the prev val6
					stop_PWM_dispatch();
 744:	0e 94 76 00 	call	0xec	; 0xec <_Z17stop_PWM_dispatchv>
					unable_dispatch_parameter();
 748:	0e 94 8b 00 	call	0x116	; 0x116 <_Z25unable_dispatch_parameterv>
					
					initiate_accept_process();
 74c:	0e 94 b4 00 	call	0x168	; 0x168 <_Z23initiate_accept_processv>
 750:	b8 cf       	rjmp	.-144    	; 0x6c2 <main+0xc0>
				}
				else
				if(successful == 0)
 752:	00 97       	sbiw	r24, 0x00	; 0
 754:	09 f0       	breq	.+2      	; 0x758 <main+0x156>
 756:	b5 cf       	rjmp	.-150    	; 0x6c2 <main+0xc0>
				{
					stop_PWM_dispatch();
 758:	0e 94 76 00 	call	0xec	; 0xec <_Z17stop_PWM_dispatchv>
					unable_dispatch_parameter();
 75c:	0e 94 8b 00 	call	0x116	; 0x116 <_Z25unable_dispatch_parameterv>
					
					Send_A_Command(0x01);//clrscr();
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 766:	a3 ef       	ldi	r26, 0xF3	; 243
 768:	b1 e0       	ldi	r27, 0x01	; 1
 76a:	11 97       	sbiw	r26, 0x01	; 1
 76c:	f1 f7       	brne	.-4      	; 0x76a <main+0x168>
 76e:	00 c0       	rjmp	.+0      	; 0x770 <main+0x16e>
 770:	00 00       	nop
					_delay_ms(2);
					Send_A_String("Plz Collect Coin");
 772:	c7 01       	movw	r24, r14
 774:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
					
					Send_A_Command(0xC0);//next line;
 778:	80 ec       	ldi	r24, 0xC0	; 192
 77a:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 77e:	83 ef       	ldi	r24, 0xF3	; 243
 780:	91 e0       	ldi	r25, 0x01	; 1
 782:	01 97       	sbiw	r24, 0x01	; 1
 784:	f1 f7       	brne	.-4      	; 0x782 <main+0x180>
 786:	00 c0       	rjmp	.+0      	; 0x788 <main+0x186>
 788:	00 00       	nop
					_delay_ms(2);
					Send_A_String("ERROR-TRY AGAIN");
 78a:	c5 01       	movw	r24, r10
 78c:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
 790:	8f e3       	ldi	r24, 0x3F	; 63
 792:	9d e0       	ldi	r25, 0x0D	; 13
 794:	a3 e0       	ldi	r26, 0x03	; 3
 796:	81 50       	subi	r24, 0x01	; 1
 798:	90 40       	sbci	r25, 0x00	; 0
 79a:	a0 40       	sbci	r26, 0x00	; 0
 79c:	e1 f7       	brne	.-8      	; 0x796 <main+0x194>
 79e:	00 c0       	rjmp	.+0      	; 0x7a0 <main+0x19e>
 7a0:	00 00       	nop
					
					_delay_ms(1000);
					
					initiate_return_process();
 7a2:	0e 94 dd 00 	call	0x1ba	; 0x1ba <_Z23initiate_return_processv>
 7a6:	8d cf       	rjmp	.-230    	; 0x6c2 <main+0xc0>
				}
			}
			else
			if (STOCK == 0)
 7a8:	88 23       	and	r24, r24
 7aa:	09 f0       	breq	.+2      	; 0x7ae <main+0x1ac>
 7ac:	8a cf       	rjmp	.-236    	; 0x6c2 <main+0xc0>
			{
				Send_A_Command(0x01);//clrscr();
 7ae:	81 e0       	ldi	r24, 0x01	; 1
 7b0:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 7b4:	a3 ef       	ldi	r26, 0xF3	; 243
 7b6:	b1 e0       	ldi	r27, 0x01	; 1
 7b8:	11 97       	sbiw	r26, 0x01	; 1
 7ba:	f1 f7       	brne	.-4      	; 0x7b8 <main+0x1b6>
 7bc:	00 c0       	rjmp	.+0      	; 0x7be <main+0x1bc>
 7be:	00 00       	nop
				_delay_ms(2);
				Send_A_String("Plz Collect Coin");
 7c0:	c7 01       	movw	r24, r14
 7c2:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
				
				Send_A_Command(0xC0);//next line;
 7c6:	80 ec       	ldi	r24, 0xC0	; 192
 7c8:	0e 94 47 01 	call	0x28e	; 0x28e <_Z14Send_A_Commandc>
 7cc:	83 ef       	ldi	r24, 0xF3	; 243
 7ce:	91 e0       	ldi	r25, 0x01	; 1
 7d0:	01 97       	sbiw	r24, 0x01	; 1
 7d2:	f1 f7       	brne	.-4      	; 0x7d0 <main+0x1ce>
 7d4:	00 c0       	rjmp	.+0      	; 0x7d6 <main+0x1d4>
 7d6:	00 00       	nop
				_delay_ms(2);
				Send_A_String("  OUT OF STOCK  ");
 7d8:	c6 01       	movw	r24, r12
 7da:	0e 94 60 01 	call	0x2c0	; 0x2c0 <_Z13Send_A_StringPc>
 7de:	8f e3       	ldi	r24, 0x3F	; 63
 7e0:	9d e0       	ldi	r25, 0x0D	; 13
 7e2:	a3 e0       	ldi	r26, 0x03	; 3
 7e4:	81 50       	subi	r24, 0x01	; 1
 7e6:	90 40       	sbci	r25, 0x00	; 0
 7e8:	a0 40       	sbci	r26, 0x00	; 0
 7ea:	e1 f7       	brne	.-8      	; 0x7e4 <main+0x1e2>
 7ec:	00 c0       	rjmp	.+0      	; 0x7ee <main+0x1ec>
 7ee:	00 00       	nop
				
				_delay_ms(1000);
				
				initiate_return_process();				
 7f0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <_Z23initiate_return_processv>
 7f4:	66 cf       	rjmp	.-308    	; 0x6c2 <main+0xc0>
			}
		}
		else
		initiate_return_process();
 7f6:	0e 94 dd 00 	call	0x1ba	; 0x1ba <_Z23initiate_return_processv>
 7fa:	63 cf       	rjmp	.-314    	; 0x6c2 <main+0xc0>

000007fc <_exit>:
 7fc:	f8 94       	cli

000007fe <__stop_program>:
 7fe:	ff cf       	rjmp	.-2      	; 0x7fe <__stop_program>
